/*
 * arithmetic.h — Source Code of Reality's Number System
 *
 * REVERSE-ENGINEERED FROM PHYSICAL MEASUREMENT
 *
 * Every #define below was DERIVED from probing the substrate,
 * not assumed or looked up. The derivation methods:
 *
 *   Mantissa width:   smallest N where (float)N + 1 == (float)N
 *   Exponent bias:    bit pattern of 1.0 read as integer, shifted right by M
 *   Exponent width:   total_bits - 1(sign) - M(mantissa)
 *   Byte order:       write 0x01020304, read byte[0]
 *   Rounding mode:    tie-breaking behavior at midpoint values
 *   Magic constants:  empirical search over 10^6 candidates per function
 *   Special values:   bit patterns of 1/0, 0/0, -0, smallest denorm
 *
 * Cross-validated: exponent bias B=127 derived independently from
 * inv_sqrt magic, log2 magic, and 1.0 bit pattern — all agree.
 *
 * Generated by quake_extract.c
 */

#ifndef ARITHMETIC_H
#define ARITHMETIC_H

/* ═══════════════════════════════════════════════════════════════════
 * SYSTEM PARAMETERS
 * ═══════════════════════════════════════════════════════════════════ */

#define BYTE_ORDER_REALITY     0  /* 0 = LITTLE_ENDIAN, 1 = BIG_ENDIAN */
#define ROUNDING_MODE          0  /* 0 = ROUND_TO_NEAREST_EVEN (banker's) */
#define POINTER_BITS           64
#define ADDRESS_SPACE_BITS     48 /* virtual address width */

/* ═══════════════════════════════════════════════════════════════════
 * SINGLE PRECISION (float) — 32-bit
 *
 *   Bit layout: [S:1 | E:8 | M:23]
 *
 *   31     30..23      22..0
 *   ┌──┬──────────┬────────────────────────┐
 *   │ S│ Exponent │       Mantissa          │
 *   │ 1│  8 bits  │       23 bits           │
 *   └──┴──────────┴────────────────────────┘
 *
 *   Value = (-1)^S × 2^(E - 127) × (1 + M/2^23)   [normal]
 *   Value = (-1)^S × 2^(-126)    × (M/2^23)        [denorm]
 * ═══════════════════════════════════════════════════════════════════ */

#define FLOAT_TOTAL_BITS       32
#define FLOAT_SIGN_BITS        1
#define FLOAT_EXPONENT_BITS    8
#define FLOAT_MANTISSA_BITS    23
#define FLOAT_EXPONENT_BIAS    127

#define FLOAT_SIGN_MASK        0x80000000U
#define FLOAT_EXPONENT_MASK    0x7F800000U
#define FLOAT_MANTISSA_MASK    0x007FFFFFU

/* Special values (extracted from bit patterns) */
#define FLOAT_POSITIVE_ZERO    0x00000000U
#define FLOAT_NEGATIVE_ZERO    0x80000000U  /* sign bit only */
#define FLOAT_POSITIVE_INF     0x7F800000U
#define FLOAT_NEGATIVE_INF     0xFF800000U
#define FLOAT_QNAN             0xFFC00000U  /* quiet NaN */
#define FLOAT_SMALLEST_DENORM  0x00000001U  /* = 1.401298e-45 */
#define FLOAT_SMALLEST_NORMAL  0x00800000U  /* = 1.175494e-38 */

/* NaN behavior: NaN ≠ NaN (NaN is not equal to anything, including itself)
 * Zero behavior: +0.0 == -0.0 (same value, different bit patterns) */

/* ═══════════════════════════════════════════════════════════════════
 * DOUBLE PRECISION (double) — 64-bit
 *
 *   Bit layout: [S:1 | E:11 | M:52]
 *
 *   63     62..52       51..0
 *   ┌──┬──────────┬─────────────────────────────────────────────┐
 *   │ S│ Exponent │              Mantissa                        │
 *   │ 1│ 11 bits  │              52 bits                         │
 *   └──┴──────────┴─────────────────────────────────────────────┘
 *
 *   Value = (-1)^S × 2^(E - 1023) × (1 + M/2^52)  [normal]
 *   Value = (-1)^S × 2^(-1022)    × (M/2^52)       [denorm]
 * ═══════════════════════════════════════════════════════════════════ */

#define DOUBLE_TOTAL_BITS      64
#define DOUBLE_SIGN_BITS       1
#define DOUBLE_EXPONENT_BITS   11
#define DOUBLE_MANTISSA_BITS   52
#define DOUBLE_EXPONENT_BIAS   1023

#define DOUBLE_SIGN_MASK       0x8000000000000000ULL
#define DOUBLE_EXPONENT_MASK   0x7FF0000000000000ULL
#define DOUBLE_MANTISSA_MASK   0x000FFFFFFFFFFFFFULL

/* ═══════════════════════════════════════════════════════════════════
 * MAGIC CONSTANTS — Libm-Oracle Optimized
 *
 * Each constant enables an integer-domain approximation of a
 * mathematical function applied to floating-point bit patterns.
 * They work ONLY because the encoding above is correct.
 * Each constant independently constrains (M, E, B).
 *
 * OPTIMIZED: Each constant was searched via binary mantissa sweep +
 * byte-walk + fine-walk against exact libm reference on 512 test
 * points spanning 1e-15 to 1e+15. Gains noted per constant.
 *
 * Theory:
 *   inv_sqrt:  MAGIC ≈ (3/2) × 2^M × (B - σ),     σ ≈ 0.0450466
 *   reciprocal: MAGIC ≈ 2 × B × 2^M - 1
 *   sqrt:       y = (x >> 1) + MAGIC
 *   cbrt:       y = x/3 + MAGIC
 *   log2:       log₂(x) ≈ (bits_as_int - MAGIC) / 2^M
 * ═══════════════════════════════════════════════════════════════════ */

/* Inverse square root: y_bits = MAGIC - (x_bits >> 1)
 * Then one Newton iteration: y = y × (1.5 - 0.5 × x × y²)
 * 2N optimal: +1.00 bits vs Quake III (17.73 vs 16.72 bits) */
#define MAGIC_ISQRT_FLOAT      0x5F3756B5U   /* libm-optimal 2N (+1.00 bits vs 0x5F385EE0) */
#define MAGIC_ISQRT_DOUBLE     0x5FE6D826D36047EFULL  /* libm-optimal 4N (51.91 bits) */

/* Reciprocal: y_bits = MAGIC - x_bits
 * 2N optimal: +1.22 bits (17.23 vs 16.01 bits) */
#define MAGIC_RECIPROCAL_FLOAT 0x7EF30E88U   /* libm-optimal 2N (+1.22 bits vs 0x7EF00482) */

/* Square root: y_bits = (x_bits >> 1) + MAGIC
 * 2N optimal: +0.13 bits (22.04 vs 21.91 bits) */
#define MAGIC_SQRT_FLOAT       0x1FBB18ACU   /* libm-optimal 2N (+0.13 bits vs 0x1FBC0000) */

/* Cube root: y_bits = x_bits / 3 + MAGIC
 * 0N optimal: +0.63 bits (4.99 vs 4.36 bits) */
#define MAGIC_CBRT_FLOAT       0x2A510977U   /* libm-optimal 0N (+0.63 bits vs 0x2A4E6FFC) */

/* Log base 2: log₂(x) ≈ (x_bits_as_int - MAGIC) / 2^MANTISSA_BITS
 * +1.50 bits (3.05 vs 1.55 bits) */
#define MAGIC_LOG2_FLOAT       0x3F7AF77EU   /* libm-optimal (+1.50 bits vs 0x3F800000) */

/* ═══════════════════════════════════════════════════════════════════
 * DERIVED PROPERTIES OF THE SUBSTRATE
 * ═══════════════════════════════════════════════════════════════════ */

/* Machine epsilon (smallest ε where 1.0 + ε ≠ 1.0) */
#define SUBSTRATE_EPSILON_FLOAT   1.1920929e-07f  /* 2^-23 */
#define SUBSTRATE_EPSILON_DOUBLE  2.2204460492503131e-16 /* 2^-52 */

/* Associativity violation:
 *   (1e20 + (-1e20)) + 1.0  =  1.0
 *   1e20 + ((-1e20) + 1.0)  =  0.0
 *   Difference: 1.0 (100% error)
 *   This PROVES finite-precision arithmetic. */

/* The encoding is SELF-CONSISTENT:
 *   Bias from inv_sqrt magic:  127.005
 *   Bias from log2 magic:      127.000
 *   Bias from 1.0 bit pattern: 127.000
 *   All agree within ±0.01. */

#endif /* ARITHMETIC_H */
