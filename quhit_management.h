/*
 * quhit_management.h — Reality's Per-Quhit State Management
 *
 * Extracted by probing the physical substrate.
 *
 * Reality does NOT store one D^N state vector.
 * Each quhit gets its own dense 6-amplitude state (96 bytes).
 * Entanglement creates small joint states (576 bytes per pair).
 * Total memory: O(N), never O(D^N).
 *
 * Design: each quhit = Amp[6], flat dense, cache-aligned.
 *         entangled pair = Amp[36], row-major joint state.
 *         N quhits = N×96 bytes + pairs×576 bytes.
 *
 * Generated by quhit_extract.c
 */

#ifndef QUHIT_MANAGEMENT_H
#define QUHIT_MANAGEMENT_H

#include <stdint.h>
#include <string.h>
#include "born_rule.h"
#include "statevector.h"

/* ═══════════════════════════════════════════════════════
 * CONSTANTS — Reality's quhit parameters
 * ═══════════════════════════════════════════════════════ */

#define QM_D             6        /* dimension per quhit */
#define QM_LOCAL_BYTES   96       /* 6 × 16 bytes per quhit */
#define QM_JOINT_BYTES   576      /* 36 × 16 bytes per pair */
#define QM_AMP_BYTES     16       /* sizeof(Complex) */

/* ═══════════════════════════════════════════════════════
 * QUHIT STATE — Dense, always 96 bytes
 * ═══════════════════════════════════════════════════════ */

typedef struct {
    double re[QM_D];   /* real parts */
    double im[QM_D];   /* imaginary parts */
} QuhitState;

/* ═══════════════════════════════════════════════════════
 * JOINT STATE — Dense, always 576 bytes
 * ═══════════════════════════════════════════════════════ */

typedef struct {
    double re[QM_D * QM_D];   /* 36 real parts */
    double im[QM_D * QM_D];   /* 36 imaginary parts */
} QuhitJoint;

/* ═══════════════════════════════════════════════════════
 * INIT — |0⟩ basis state
 * ═══════════════════════════════════════════════════════ */

static inline void qm_init_zero(QuhitState *q) {
    memset(q, 0, sizeof(*q));
    q->re[0] = 1.0;
}

/* ═══════════════════════════════════════════════════════
 * INIT — |+⟩ uniform superposition
 * ═══════════════════════════════════════════════════════ */

static inline void qm_init_plus(QuhitState *q) {
    double amp = born_fast_isqrt((double)QM_D);
    for (int k = 0; k < QM_D; k++) { q->re[k] = amp; q->im[k] = 0.0; }
}

/* ═══════════════════════════════════════════════════════
 * ENTANGLE — Create Bell state from two independent quhits
 *
 * |ψ⟩ = (1/√D) Σ|k⟩|k⟩
 * The two QuhitStates are CONSUMED. Returns a JointState.
 * ═══════════════════════════════════════════════════════ */

static inline void qm_entangle_bell(QuhitJoint *j) {
    memset(j, 0, sizeof(*j));
    double amp = born_fast_isqrt((double)QM_D);
    for (int k = 0; k < QM_D; k++)
        j->re[k * QM_D + k] = amp;
}

/* ═══════════════════════════════════════════════════════
 * ENTANGLE — Tensor product |α⟩⊗|β⟩
 * ═══════════════════════════════════════════════════════ */

static inline void qm_entangle_product(QuhitJoint *j,
        const QuhitState *a, const QuhitState *b) {
    for (int ia = 0; ia < QM_D; ia++)
        for (int ib = 0; ib < QM_D; ib++) {
            int idx = ia * QM_D + ib;
            j->re[idx] = a->re[ia]*b->re[ib] - a->im[ia]*b->im[ib];
            j->im[idx] = a->re[ia]*b->im[ib] + a->im[ia]*b->re[ib];
        }
}

/* ═══════════════════════════════════════════════════════
 * DISENTANGLE — Break entanglement, return to locals
 *
 * After measurement collapses the joint state, extract
 * the individual quhit states from the joint.
 * ═══════════════════════════════════════════════════════ */

static inline void qm_disentangle(const QuhitJoint *j,
        int measured_a, QuhitState *qa, QuhitState *qb) {
    /* After A collapses to |measured_a⟩:
     * B's state = joint[measured_a, :] (renormalized) */
    memset(qa, 0, sizeof(*qa));
    qa->re[measured_a] = 1.0;

    memset(qb, 0, sizeof(*qb));
    double norm2 = 0;
    for (int b = 0; b < QM_D; b++) {
        int idx = measured_a * QM_D + b;
        qb->re[b] = j->re[idx];
        qb->im[b] = j->im[idx];
        norm2 += qb->re[b]*qb->re[b] + qb->im[b]*qb->im[b];
    }
    if (norm2 > 0) {
        double scale = born_fast_isqrt(norm2);
        for (int b = 0; b < QM_D; b++) {
            qb->re[b] *= scale;
            qb->im[b] *= scale;
        }
    }
}

/* ═══════════════════════════════════════════════════════
 * TOTAL PROBABILITY — normalization check
 * ═══════════════════════════════════════════════════════ */

static inline double qm_total_prob(const QuhitState *q) {
    double total = 0;
    for (int k = 0; k < QM_D; k++)
        total += q->re[k]*q->re[k] + q->im[k]*q->im[k];
    return total;
}

static inline double qm_total_prob_joint(const QuhitJoint *j) {
    double total = 0;
    for (int k = 0; k < QM_D * QM_D; k++)
        total += j->re[k]*j->re[k] + j->im[k]*j->im[k];
    return total;
}

/* ═══════════════════════════════════════════════════════
 * MEMORY COST — Reality's accounting
 * ═══════════════════════════════════════════════════════ */

static inline size_t qm_memory_cost(int n_independent, int n_pairs) {
    return (size_t)n_independent * QM_LOCAL_BYTES
         + (size_t)n_pairs * QM_JOINT_BYTES;
}

#endif /* QUHIT_MANAGEMENT_H */
